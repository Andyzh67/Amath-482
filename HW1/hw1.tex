\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}
\lstset{language=Matlab,%
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    numbers=left,%
    numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=9pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
}
\lstset{language=Matlab}
\usepackage{indentfirst}
\begin{document}
\title{Amath 482 homework 1: An ultrasound problem}
\author{Andy Zhang}
\maketitle

\begin{abstract}
This report describes the way to locate the marble swallowed by a dog by operating on data in frequency space. Due to the noise generated by the fluid movement in the dog's intestines, we need to locate the center frequency of the marble by averaging 20 lines of data and find the maximum. Then we can determine the position of the marble by filtering out the noise around center frequency and form a trajectory in spatial domain. The final position of the marble can be determined by the 20th line of data.

\end{abstract}

\section{Introduction}
My dog swallowed a marble, which went into its intestines. By using ultrasound, the vet collected the data of the marble's trajectory. However, the dog kept moving and fluid inside its intestines generated highly noisy data. Our goal is to filter out the noises and determine the position of the marble so that I can save my dog!


\section{Theoretical Background}
\subsection{Fourier Transform}
The Fourier Transform is the basis of this method, which helps us to transform the data from time or spatial domain to frequency domain. The Fourier Transform and its inverse are defined as:
\begin{equation}\label{1}
F(k) = \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{\infty} e^{-ikx}f(x) dx
\end{equation}
\begin{equation}\label{2}
f(x) = \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{\infty} e^{ikx}F(k) dk 
\end{equation}\par
We can understand Fourier Transform by thinking it as disassembling the periodic function into sums of sines and cosines, proved by Euler's formula: $e^{ikx} = cos(kx) + isin(kx)$, where k represents wavenumbers and the term $e^{ikx}$ represents oscillatory integration kernel. Fourier Transform is defined over the entire real line $x\in[{-\infty},{\infty}]$, whereas our computational domain is finite over $x\in[-L,L]$. \par
\vskip 0.5cm
We use commands \textbf{\emph{fft(u)}} and \textbf{\emph{ifft(u)}} in Matlab to do Fast Fourier Transform and its inverse, with operation order $O(NlogN)$. The lower operation order of Fast Fourier Transform makes more practical use when dealing with large amounts of data. We also need \textbf{L} (spatial or time domain) and \textbf{n}  (Fourier modes) to determine the frequencies \textbf{k}. Note that Fast Fourier Transform assumes a periodic signals, that is, frequency \textbf{k} is in unit of \textbf{rad/time or spatial unit}. That's why we rescale \textbf{k} by $2{\pi}/L$. In this project, commands \textbf{\emph{fftn(u)}} and \textbf{\emph{ifftn(u)}} are used to deal with multi-dimensional arrays.

\subsection{Gaussian Filter}
Applying a Gaussian filter around the center frequency of the given data helps us eliminate the noises and determine the spatial trajectory of marble. A commonly used Gaussian filter is defined as:
\begin{equation}\label{3}
F(k) = e^{-\tau(k - k_0)^2},
\end{equation}
where ${\tau}$ determines the width of filter window and \textbf{k} represents the wavenumbers(the frequencies over finite domain). $k_0$ is the frequency we are interested in the frequency space, in this case, the center frequencies of marble. \par
\vskip 0.5cm
The Gaussian Filter can effectively eliminate the noise away from the center frequencies. However, since we're dealing with data in 3-d dimensions, so we have to modify the filter to:
\begin{equation}\label{4}
F(k) = e^{-\tau((Kx - xf)^2 + (Ky - yf)^2 + (Kz - zf)^2)},
\end{equation}
where xf, yf, zf represent the center frequency at x, y, and z dimensions, and Kx, Ky, Kz are grids that that consist of frequencies in three dimensions. It filters out the noise in all dimensions.

\subsection{Averaging}
Based on the idea that white-noise can be modeled as normally distributed variables with zero mean to each Fourier component, we can then average up the sum of many data, with a zero mean for added-up white noises as well. This is practical for continuous signal processing because the more signals we add up and take average, the more precisely and clearly the center frequency is shown. If we are dealing with data instead of plots, like in this case, the center frequency can be determined by the coordinates of the maximum element in the averaged up data.

\section{Algorithm Implementation and Development}
\subsection*{Prepare for Fourier Transform}
To start with, we need the spatial domain \textbf{L} and Fourier modes \textbf{n}, which are pre-set to 15 and 64 respectively. Since we are solving it numerically, so we have to discrete the domain into \textbf{n+1} points and take the first \textbf{n} points to form periodic boundary conditions. \par
Then we need to rescale the frequencies \textbf{k} by $2{\pi}/2L$ because Fast Fourier Transform assumes a $2{\pi}$ periodic signals and the domain ranges from $-L$ to $L$, that is a total $2L$ units long. We also have to \textbf{fftshift()} the frequencies so that the zero frequency is staying at the middle of the array. \par
Since we are dealing with multidimensional data, we have to create spatial grids for X, Y, and Z, and frequency grids for Kx, Ky, and Kz, with the size of 64 by 64 by 64.
\vskip 0.5cm
\subsection*{Reshape the data, add them up, and take average}
Then we need to reshape the 20 lines of data into a 64 by 64 by 64 grid named \textbf{u} and apply \textbf{fftn()} to \textbf{u} because we are curious about the center frequencies in the frequency space. After taking average by dividing 20, we normalize the grid and name it \textbf{uave}.
\vskip 0.5cm
\subsection*{Find the center frequency}
The normalized \textbf{uave} has its maximum element of 1 and we are going to find the \textbf{index} of this \textbf{aveMax} in \textbf{uave} by calling $[aveMax, Index] = max(uave(:))$, in which \textbf{(uave(:))} changes the grid into a vector so that we can use an index to represent three-dimensional coordinates. Then we call $[Px,Py,Pz] = ind2sub(size(uave), Index)$ to find the arrays of \textbf{uave} that \textbf{aveMax} is in. Finally, we apply the coordinate (Px, Py, Pz) to \textbf{Kx}, \textbf{Ky}, and \textbf{Kz} to find the center frequencies in all dimensions of frequency space.



\subsection*{Make sure we find the correct center frequency}
We are calling the \textbf{isosurface} command to present the frequencies according to given isovalues. As Figure(1) shows, with an isovalue of 0.4, it's still hard to find the frequency of marble under the influence of noises. Then I gradually increase the isovalue up to 0.9, which is close to the ceiling of isovalue that we can't see anything in the plot. We can check the coordinate of frequency by clicking onto it, which shows the same frequency found by the above algorithm. The center frequency calculated is provided in the \textit{\textbf{computational results}} section below.


\begin{figure}[b]
	\caption{Downward trajectory of the marble applying filters with
	 different $\tau$}
	\centering
	\includegraphics[width=0.5\textwidth]
    {tau.jpg}
\end{figure}

\subsection*{Build a Gaussian filter and find the trajectory}
As shown above in the \textbf{Gaussian filter} section, we build such filter that filters out noises in all dimensions.
\begin{equation}\label{5}
F(k) = e^{-\tau((Kx - xf)^2 + (Ky - yf)^2 + (Kz - zf)^2)}
\end{equation} \par
We reshape the data again, and transform it into frequency space by \textbf{fftn()}. Then we apply \textbf{fftshift()} to match with corresponding frequencies and array multiply the resulting grid and filter. We then have to do \textbf{ifftshift()} because the filter is based on frequencies being applied \textbf{fftshift()} and the resulting grid also gets shifted once. We finally take the frequency information back to spatial domain to get \textbf{uf}. \par
\vskip 0.5cm
We apply the same idea as finding the center frequency. $(xt, yt, zt)$ is the coordinate of the max frequency per line of data. Applying this coordinate to $X, Y, Z$ results in the actual position of marble according to each data line. Connecting them all forms the trajectory. \par

I've tested on three different values of $\tau$, that are 0.1, 0.3, and 0.9. Figure(2) represents the downward view of trajectories for three cases and I find the trajectory seems most stable when $\tau$ = 0.3, thus I take it as the appropriate $\tau$ for the data in this case.


\begin{figure}[h]
	\caption{Trajectory of the marble in spatial domain with desired $\tau$}
	\centering
    \includegraphics[width=0.8\textwidth]
    {3.jpg}
\end{figure}

\section{Computational Results}
\subsection*{Center frequency}
The center frequency of the marble is:
\begin{equation}\label{6}
xf = 1.8850, yf = -1.0472, zf = 0
\end{equation}
We need this center frequency so that we can build a filter and trace the marble in spatial domain.

\subsection*{Trajectory of marble}
As shown by Figure(3), it represents the marble's trajectory from all 20 lines of data. The highlighted marker represents the 20th data measurement and it's the position for the vet to use an intense acoustic wave to break the marble.

\subsection*{The spacial position of marble in 20th data measurement}
It's the last row vector in \textbf{trajectory}, with coordinate:
\begin{equation}\label{7}
x=-5.250,y=4.2188,z=-6.0938
\end{equation}
\section{Summary and Conclusion}
From this assignment, we can solve the case by alternately operate on data in spatial or frequency domain. Generally, we can solve the problem by simply finding the center frequency through averaging the data, build an appropriate Gaussian filter that denoise the data, and finding the positions of marble by analysing the data. One needs to grasp Fourier Transform and the ideas behind filter and averaging in order to solve similar problems. 

\section{Appendix A}
\noindent
\textbf{ut = fftn(u)} returns the multidimensional Fourier Transform of N-dimensional array u.\par
\vskip 0.5cm
\noindent
\textbf{uf = iffrn(utf)} returns the multidimensional inverse Fourier Transform of N-dimensional array utf.\par
\vskip 0.5cm
\noindent
\textbf{ks = fftshift(k) or k = ifftshift(k)} rearranges the Fourier Transform by shifting the zero frequency component to the middle of the array. For N-dimensional arrays, it swaps "half-space" along each dimension. "ifftshift()" is the inverse. \par
\vskip 0.5cm
\noindent
\textbf{u(:,:,:)=reshape(Undata(i,:),n,n,n)} reshapes the i-th row of Undata to a grid \textbf{u} with size of n by n by n.\par
\vskip 0.5cm
\noindent
\textbf{[Px,Py,Pz] = ind2sub(size(uave), Index)} returns the array of Px, Py, and Pz containing the equivalent subscripts in different dimensional arrays according to the size of grid and given index.\par
\vskip 0.5cm
\noindent
\textbf{isosurface(X, Y, Z, V, isovalue)} computes the isosurface geometry for data V at given isovalue. \par
\vskip 0.5cm
\noindent
\textbf{plot3(X, Y, Z)} plots 3 dimensional graph. It can plot points or lines according to the data type of X, Y, and Z.
\vskip 0.5cm

\newpage

\section{Appendix B}
\lstinputlisting[language=Matlab]{HW1.m}



\end{document}